#!/usr/bin/liquidsoap

# ============================================================
# Hermes Radio — Liquidsoap Playout Script
# Compatible with Liquidsoap 2.1.3 (Debian bookworm apt)
# ============================================================

# --- Allow running as root (Docker) ---
set("init.allow_root", true)

# --- Logging ---
set("log.file.path", "/opt/hermes/data/logs/liquidsoap.log")
set("log.stdout", true)
set("log.level", 4)

# --- Server (Unix socket for FastAPI control) ---
set("server.socket", true)
set("server.socket.path", "/tmp/liquidsoap.sock")
set("server.socket.permissions", 0o660)
set("server.telnet", false)

# --- Sources ---

# Music: shuffle playlist from m3u file (generated by start_playout.sh)
music = playlist(
  id="music",
  mode="normal",
  reload=600,
  reload_mode="rounds",
  "/opt/hermes/music/playlist.m3u"
)

# Break queue (regular breaks — waits for track end)
breaks = request.queue(id="breaks")

# Stings queue (breaking — interrupts immediately)
stings = request.queue(id="stings")

# --- Track counter + webhook to FastAPI ---
track_count = ref(0)

# Sanitize strings for safe JSON embedding (Liquidsoap 2.1.3 has no JSON serializer)
# Replaces chars that would break JSON string values
def json_safe(s)
  s = string.replace(pattern="\\\\", (fun(_) -> "/"), s)
  s = string.replace(pattern="\"", (fun(_) -> "'"), s)
  s = string.replace(pattern="\\n", (fun(_) -> " "), s)
  s = string.replace(pattern="\\r", (fun(_) -> ""), s)
  s
end

music.on_track(fun(m) -> begin
  track_count := !track_count + 1;

  artist = json_safe(m["artist"]);
  title = json_safe(m["title"]);
  filename = json_safe(m["filename"]);

  payload = '{"event":"TRACK_ENDED","track":{"artist":"' ^ artist ^ '","title":"' ^ title ^ '","filename":"' ^ filename ^ '"},"tracks_since_last_break":' ^ string_of(!track_count) ^ '}';

  ignore(
    http.post(
      headers=[("Content-Type", "application/json")],
      data=payload,
      "http://127.0.0.1:8100/api/playout/event"
    )
  )
end)

# --- Composition ---
# Music with safety: always falls back to blank if music not ready yet
safe_music = fallback(
  id="safe_music",
  track_sensitive=false,
  [music, blank(id="security")]
)

# Breaks: track-sensitive (wait for current track to end)
radio = fallback(
  id="radio",
  track_sensitive=true,
  [breaks, safe_music]
)

# Stings: not track-sensitive (interrupt immediately)
radio = fallback(
  id="with_stings",
  track_sensitive=false,
  [stings, radio]
)

# --- Server commands (callable via Unix socket) ---
server.register(
  namespace="hermes",
  description="Reset track counter",
  usage="reset_counter",
  "reset_counter",
  fun(_) -> begin
    track_count := 0;
    "Counter reset to 0"
  end
)

server.register(
  namespace="hermes",
  description="Get current track count",
  usage="track_count",
  "track_count",
  fun(_) -> begin
    string_of(!track_count)
  end
)

server.register(
  namespace="hermes",
  description="Skip current track",
  usage="skip",
  "skip",
  fun(_) -> begin
    source.skip(radio);
    "Skipped"
  end
)

# NOTE: music.reload is auto-registered by playlist(id="music", ...)
# The admin UI sends "music.reload" via the Unix socket and it works
# when playout is running. No manual server.register needed.

# --- Output: WAV to named pipe (FIFO read by FFmpeg) ---
output.file(
  %wav(
    stereo=true,
    channels=2,
    samplesize=16,
    header=true
  ),
  fallible=false,
  reopen_on_metadata=false,
  "/tmp/hermes_audio.fifo",
  radio
)
